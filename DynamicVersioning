
Overview

Dynamic Versioning is a build versioning technique that allows an application to create a unique release version at build time. This unique version has a granularity of 1 sec and allows us to build the same application at basically the same time. This technique affords us the following benefits:

This alleviates the need for incrementation mechanisms and allows us to Build Applications in Parallel.
We can switch to building only release artifacts in Continous Integration systems, allowing us to adopt a Build Artifact Promotion model.
It allows us to better describe Dependency Version Discovery using versioning ranges.
It allows us to build less often than the existing static dependency versioning system.
This technique comes with the following caveats:

Build commands are more difficult and require additional knowledge of the build application (maven)
Build Lifecycle can become a concern if steps aren't taken to educate consumers


Presentation

Implementation

Implementation is done entirely through the development build and versioning declaration system (maven) and requires that the developer pay closer attention to some lifecycle nuances in their chosen build and versioning declaration system. This technique can be broken down into the following categories, all categories are not inclusive and can be used piece-mill.

Dynamic Version

Dynamic Versioning allows the application to have a unique version each time it is built, allowing for easier integration with Continuous Integration and Deployment systems. This technique requires changes to your build and versioning declaration system and the use of a flattening plugin, to ensure that the actual dynamic version is used throughout the build and deployment lifecycle.

Add the dynamic version and the following properties to parent pom:
<project ...>
...
  <version>1.0.${version.timestamp}</version>
...
  <properties>
    ...
    <maven.build.timestamp.format>yyyyMMddHHmmss</maven.build.timestamp.format>
    <version.timestamp>${maven.build.timestamp}</version.timestamp>
    ...
  </properties>
...
</project>



Use the `flatten-maven-plugin`[2] to ensure that the dynamic version variable is flattened when built and deployed. Note: if you don't use this plugin when deploying you can see strange build and deployment behavior.
Version Ranges (Dependencies)

Another useful technique to employ in the overall topic of dynamic versioning is the use of build time dependency ranges, allowing a developer to specify a range of dependency versions that they would like to consume. This allows for less manual work regarding dependency versioning and if the release / versioning contract is maintained, allows for build and deployment assumptions regarding dependency stability. This method normally relies on the dependency to enforce versioning mechanisms like Semantic Versioning (semver[1]), to create this release / versioning contract with their consumers.

Establish predictable version ranges for dynamic dependencies. The following example uses a version range from `2.0.0` upward and less than `3.0.0`, allowing this application to consume the most recent version within that range.
<project ...>
...
        <dependency>
            <groupId>com.sony.snei.kamaji</groupId>
            <artifactId>common-utils</artifactId>
            <version>(2.0.0,3.0.0)</version>
        </dependency>
 
        <dependency>
            <groupId>com.sony.snei.kamaji</groupId>
            <artifactId>common-configuration</artifactId>
            <version>(2.0.0,3.0.0)</version>
        </dependency>
...
</project>



Use the `versions-maven-plugin:resolve-ranges`[3] to resolve version ranges prior to building applications, this will greatly reduce the time it takes to build and deploy applications. Note: if you don't use this plugin when deploying you can see strange build and deployment behavior.
Putting it All Together

We recommend that you utilize both of these techniques to control your application versions dynamically and to source dependencies at build time, but it is possible to use these techniques piece-mill. Below are some build and deploy lifecycle examples, using combinations of both techniques.

Dynamic Versioning with Version Ranges Example (Maven)

The following maven commands will resolve version ranges and build and deploy an application using a dynamic version. These examples declare plugin usage on the commandline, but you could declare the required plugins in your pom.xml file. Notice that we are resolving ranges before flattening or building the application, this reduces the time it takes to resolve ranges as Maven's built-in functionality for this is slow and tedious. Also, note that we are creating a version timestamp prior to executing Maven, we do this as the behavior of the `${maven.build.timestamp}` variable is unpredictable and can cause issues for parent and leaf projects.

]$ mvn -B org.codehaus.mojo:versions-maven-plugin:resolve-ranges

]$ mvn -B org.codehaus.mojo:flatten-maven-plugin:flatten deploy -Dversion.timestamp=$( TZ=":UTC" date +%Y%m%d%H%M%S )

]$ mvn -B -o org.codehaus.mojo:versions-maven-plugin:revert -DskipTests=true

These commands can be run in a single action also, but please note that the resolve ranges and revert goals need to be executed out-of-band or you could see unexpected behavior.

]$ mvn -B org.codehaus.mojo:versions-maven-plugin:resolve-ranges ; \

   mvn -B org.codehaus.mojo:flatten-maven-plugin:flatten deploy -Dversion.timestamp=$( TZ=":UTC" date +%Y%m%d%H%M%S ) ; \

   mvn -B -o org.codehaus.mojo:versions-maven-plugin:revert -DskipTests=true

These commands will run the following maven goals:

Resolves version ranges in pom.xml files
Generates `.flatten-pom.xml` files, in which all variables, properties, etc. located in the pom.xml file will be converted into static values
Run all goals associated with the deploy goal for the packing method specified in the pom.xml file
Deploy the application using the distribution management settings specified in the pom.xml file
Offline reversion of version ranges in pom.xml, restoring version ranges, note: this goal is executed offline to prevent re-downloading plugins and dependencies
 

Dynamic Versioning Example (Maven)

The following maven commands will build and deploy an application using a dynamic version. These examples declare plugin usage on the commandline, but you could declare the required plugins in your pom.xml file. Notice that we are creating a version timestamp prior to executing Maven, we do this as the behavior of the `${maven.build.timestamp}` variable is unpredictable and can cause issues for parent and leaf projects.

]$ mvn -B org.codehaus.mojo:flatten-maven-plugin:flatten deploy -Dversion.timestamp=$( TZ=":UTC" date +%Y%m%d%H%M%S )

This command will run the following maven goals:

Generate a `.flatten-pom.xml` file, in which all variables, properties, etc. located in the pom.xml file will be converted into static values
Run all goals associated with the deploy goal for the packing method specified in the pom.xml file
Deploy the application using the distribution management settings specified in the pom.xml file
 

Version Ranges Example (Maven)

The following maven commands will resolve ranges for an application using version ranges. These examples declare plugin usage on the commandline, but you could declare the required plugins in your pom.xml file. Notice that we are resolving ranges before flattening or building the application, this reduces the time it takes to resolve ranges as Maven's built-in functionality for this is slow and tedious.

]$ mvn -B org.codehaus.mojo:versions-maven-plugin:resolve-ranges

]$ mvn -B deploy

]$ mvn -B -o org.codehaus.mojo:versions-maven-plugin:revert -DskipTests=true

This command will run the following maven goals:

Resolves version ranges in pom.xml files
Run all goals associated with the deploy goal for the packing method specified in the pom.xml file
Deploy the application using the distribution management settings specified in the pom.xml file
Revert version ranges in pom.xml, restoring version ranges
 

Frequently Asked Questions

How Do I Hotfix A Deployed Version?

Hotfixing a deployed version is pretty simple but does require that you perform some manual steps:

Checkout the git tag that you are trying to hotfix (notice the "tags/" portion, this is required to checkout the correct tag):
$ cd kamaji-entitlements
$ git checkout tags/1.1.20170228205242



Confirm that the `.flattened-pom.xml` file has the same version number as the git tag
Make the functional changes you would like to make to the application / library
Update the `.flattened-pom.xml` file with a hotfix postfix:
<project ...>
...
    <version>1.1.20170228205242-hf1</version>
...
</project>



Run the hotfix_helper.py[4] script to create a hotfix pom file (you can use a docker container or run the script locally):
 
Docker
$ docker run -it --rm registry.docker.sie.sony.com/raptor/hotfix_helper:1.0.0 --pom pom.xml --flattened .flattened-pom.xml --output hotfix-pom.xml



Local Python
$ python hotfix_helper.py --pom pom.xml --flattened .flattened-pom.xml --output hotfix-pom.xml



Deploy the new artifact to nexus and other storage systems (note that deploy credentials are required for this action):
$ docker-compose run deploy



How Does This Tie Into DwD and Team Jenkins?

